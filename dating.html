<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Uzone • Match</title>

  <!-- Tab icon -->
  <link rel="icon" type="image/png" href="logo.png" />

  <style>
    :root{
      --accent:#b00b55;
      --bg:#0b0b10;
      --panel: rgba(255,255,255,.06);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --border: rgba(255,255,255,.14);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(176,11,85,.30), transparent 60%),
        radial-gradient(900px 600px at 80% 30%, rgba(176,11,85,.18), transparent 55%),
        radial-gradient(700px 500px at 50% 90%, rgba(255,255,255,.06), transparent 60%),
        var(--bg);
    }

    header{
      width:min(1100px, 92vw);
      margin:18px auto 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:14px 16px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,07), rgba(255,255,255,04));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }
    .left{display:flex; align-items:center; gap:12px; min-width:0;}
    .left img{width:38px;height:38px;object-fit:contain; filter: drop-shadow(0 8px 16px rgba(0,0,0,35));}
    .title{display:grid; gap:2px; min-width:0;}
    .title h1{margin:0;font-size:18px;letter-spacing:.2px}
    .title .sub{color:var(--muted);font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .right{display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
    .chip{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,18);
      font-size:13px;
      color:rgba(255,255,255,85);
    }

    /* Buttons: match the glassy hub theme + accent glow */
    .btn{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(176,11,85,45);
      background: linear-gradient(180deg, rgba(176,11,85,22), rgba(0,0,0,18));
      color:rgba(255,255,255,92);
      font-weight:900;
      cursor:pointer;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      box-shadow: 0 14px 40px rgba(176,11,85,10);
      transition: transform .12s ease, filter .12s ease, border-color .12s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(176,11,85,70); filter: brightness(1.05); }
    .btn:active{ transform: translateY(0px) scale(.99); }

    main{
      width:min(1100px, 92vw);
      margin:16px auto 28px auto;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      main{ grid-template-columns:1fr; }
    }

    .panel{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,07), rgba(255,255,255,04));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelPad{ padding:14px; }
    .panelHead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      padding:14px;
      border-bottom:1px solid rgba(255,255,255,10);
      background: rgba(0,0,0,14);
    }
    .panelHead .h{
      margin:0;
      font-size:16px;
      letter-spacing:.2px;
    }
    .panelHead .p{
      margin:4px 0 0 0;
      color:rgba(255,255,255,70);
      font-size:13px;
      line-height:1.35;
    }

    .toggleRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .seg{
      display:flex;
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,18);
      border-radius: 999px;
      overflow:hidden;
    }
    .seg button{
      border:0;
      background: transparent;
      color: rgba(255,255,255,75);
      font-weight:900;
      padding:8px 12px;
      cursor:pointer;
    }
    .seg button.on{
      background: rgba(176,11,85,25);
      color: rgba(255,255,255,92);
    }

    .msg{
      display:none;
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,16);
      color: rgba(255,255,255,88);
      font-size:13px;
      line-height:1.35;
    }
    .msg.ok{ border-color: rgba(80,255,160,25); background: rgba(80,255,160,10); }
    .msg.error{ border-color: rgba(255,80,120,25); background: rgba(255,80,120,10); }

    /* Swipe Card */
    .cardWrap{ padding:14px; }
    .swipeCard{
      border:1px solid rgba(255,255,255,14);
      border-radius: 18px;
      background: rgba(0,0,0,18);
      overflow:hidden;
    }
    .imgArea{
      position:relative;
      width:100%;
      aspect-ratio: 4/5;
      background: rgba(0,0,0,40);
    }
    .imgArea img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      filter: saturate(1.05);
    }
    .imgNav{
      position:absolute;
      inset:0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:10px;
      pointer-events:none;
    }
    .imgNav button{
      pointer-events:auto;
      width:42px;height:42px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,16);
      background: rgba(0,0,0,30);
      color:rgba(255,255,255,92);
      font-weight:900;
      cursor:pointer;
      backdrop-filter: blur(10px);
    }
    .imgNav button:disabled{ opacity:.35; cursor:not-allowed; }
    .thumbs{
      display:flex;
      gap:8px;
      padding:10px;
      overflow:auto;
      border-top:1px solid rgba(255,255,255,10);
      background: rgba(0,0,0,18);
    }
    .thumb{
      width:58px;
      height:58px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,22);
      overflow:hidden;
      flex: 0 0 auto;
      cursor:pointer;
      opacity:.9;
      position:relative;
    }
    .thumb img{ width:100%; height:100%; object-fit:cover; display:block; }
    .thumb.active{ outline:2px solid rgba(176,11,85,70); opacity:1; }

    .cardMeta{ padding:12px; display:grid; gap:8px; }
    .nameRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .nameRow .nm{ font-size:18px; font-weight:900; letter-spacing:.2px; }
    .nameRow .age{ color:rgba(255,255,255,70); font-size:13px; }
    .bio{ color:rgba(255,255,255,78); font-size:13px; line-height:1.4; }
    .tags{ display:flex; flex-wrap:wrap; gap:8px; }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,14);
      color:rgba(255,255,255,82);
      font-size:12px;
      font-weight:800;
    }

    .swipeActions{
      display:flex;
      gap:10px;
      padding:12px;
      border-top:1px solid rgba(255,255,255,10);
      background: rgba(0,0,0,18);
    }
    .circleBtn{
      flex:1;
      padding:12px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,18);
      color:rgba(255,255,255,92);
      font-weight:950;
      cursor:pointer;
    }
    .circleBtn.good{
      border-color: rgba(80,255,160,25);
      background: rgba(80,255,160,10);
    }
    .circleBtn.bad{
      border-color: rgba(255,80,120,25);
      background: rgba(255,80,120,10);
    }
    .circleBtn:disabled{ opacity:.5; cursor:not-allowed; }

    /* Right side lists */
    .list{ padding:14px; display:grid; gap:10px; }
    .listTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:2px;
    }
    .listTop .h{
      margin:0;
      font-size:16px;
      letter-spacing:.2px;
    }
    .empty{
      border:1px dashed rgba(255,255,255,18);
      border-radius:16px;
      padding:14px;
      color:rgba(255,255,255,70);
      font-size:13px;
      display:none;
    }
    .matchRow{
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,18);
      border-radius:16px;
      padding:10px;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .matchAvatar{
      width:44px;height:44px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,14);
      overflow:hidden;
      flex:0 0 auto;
      background: rgba(0,0,0,25);
    }
    .matchAvatar img{ width:100%; height:100%; object-fit:cover; display:block; }
    .matchMeta{ min-width:0; flex:1; display:grid; gap:2px; }
    .matchName{
      font-weight:950;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .matchSub{
      color:rgba(255,255,255,68);
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .rowBtns{
      display:flex;
      gap:8px;
      flex:0 0 auto;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .miniBtn{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,18);
      color:rgba(255,255,255,92);
      font-weight:900;
      cursor:pointer;
      font-size:12px;
    }
    .miniBtn.good{
      border-color: rgba(80,255,160,25);
      background: rgba(80,255,160,10);
    }
    .miniBtn.bad{
      border-color: rgba(255,80,120,25);
      background: rgba(255,80,120,10);
    }

    /* Match modal */
    .modal{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,72);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:999;
    }
    .modalCard{
      width:min(560px, 96vw);
      border-radius: 18px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,35);
      box-shadow: var(--shadow);
    }
    .modalHead{
      padding:14px;
      border-bottom:1px solid rgba(255,255,255,10);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
    }
    .modalHead .h{ margin:0; font-size:16px; letter-spacing:.2px; }
    .closeX{
      width:38px;height:38px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,14);
      background: rgba(0,0,0,18);
      color:rgba(255,255,255,92);
      font-weight:950;
      cursor:pointer;
    }
    .modalBody{ padding:14px; display:grid; gap:12px; }
    .bubbleRow{ display:flex; gap:12px; align-items:center; justify-content:center; }
    .bubble{
      width:74px;height:74px;
      border-radius:22px;
      border:1px solid rgba(255,255,255,14);
      overflow:hidden;
      background: rgba(0,0,0,25);
    }
    .bubble img{ width:100%; height:100%; object-fit:cover; display:block; }
    .matchTitle{
      text-align:center;
      font-size:18px;
      font-weight:950;
      letter-spacing:.2px;
    }
    .modalActions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .modalActions a, .modalActions button{
      min-width: 150px;
    }
  </style>
</head>

<body>
  <header>
    <div class="left">
      <img src="logo.png" alt="Uzone logo" />
      <div class="title">
        <h1>Match</h1>
        <div class="sub" id="subline">Loading…</div>
      </div>
    </div>

    <div class="right">
      <span class="chip" id="creditsChip">Credits: 0</span>
      <a class="btn" href="hub.html">Hub</a>
    </div>
  </header>

  <main>
    <!-- LEFT: SWIPE -->
    <section class="panel">
      <div class="panelHead">
        <div>
          <h2 class="h">Swipe</h2>
          <div class="p">Swipe and match</div>
        </div>

        <div class="toggleRow">
          <div class="seg" aria-label="Gender search toggle">
            <button id="findFemale" class="on" type="button">Find women</button>
            <button id="findMale" type="button">Find men</button>
          </div>
          <button class="btn" id="refreshBtn" type="button">Refresh</button>
        </div>
      </div>

      <div class="panelPad">
        <div class="msg" id="msgBox" aria-live="polite"></div>

        <div class="cardWrap">
          <div class="swipeCard" id="swipeCard">
            <div class="imgArea">
              <img id="mainImg" alt="Profile" />
              <div class="imgNav">
                <button id="prevImg" type="button">‹</button>
                <button id="nextImg" type="button">›</button>
              </div>
            </div>

            <div class="thumbs" id="thumbs"></div>

            <div class="cardMeta">
              <div class="nameRow">
                <div class="nm" id="candName">—</div>
                <div class="age" id="candAge"></div>
              </div>
              <div class="bio" id="candBio"></div>
              <div class="tags" id="candTags"></div>
            </div>

            <div class="swipeActions">
              <button class="circleBtn bad" id="nopeBtn" type="button">Pass</button>
              <button class="circleBtn good" id="likeBtn" type="button">Like</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- RIGHT: MATCHES + LIKED YOU -->
    <section class="panel">
      <div class="panelHead">
        <div>
          <h2 class="h">Matches</h2>
          <div class="p">Message or remove someone from your matches.</div>
        </div>

        <button class="btn" id="refreshMatchesBtn" type="button">Refresh</button>
      </div>

      <div class="list">
        <div class="empty" id="matchesEmpty">No matches yet.</div>
        <div id="matchesList"></div>

        <hr style="border:0;border-top:1px solid rgba(255,255,255,10); width:100%; margin:8px 0;" />

        <div class="listTop">
          <h3 class="h" style="margin:0;">Liked you</h3>
          <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
            <button class="miniBtn" id="revealLikeBtn" type="button" disabled>Reveal (1 credit)</button>
            <button class="miniBtn good" id="superLikeBtn" type="button" disabled>Super Like (1 credit)</button>
          </div>
        </div>

        <div class="empty" id="likedEmpty">No likes yet.</div>
        <div id="likedList"></div>
      </div>
    </section>
  </main>

  <!-- MATCH MODAL -->
  <div class="modal" id="matchModal" aria-hidden="true">
    <div class="modalCard">
      <div class="modalHead">
        <h3 class="h">It’s a match!</h3>
        <button class="closeX" id="closeMatch" type="button">✕</button>
      </div>

      <div class="modalBody">
        <div class="bubbleRow">
          <div class="bubble"><img id="meBubble" alt="Me" /></div>
          <div class="bubble"><img id="themBubble" alt="Them" /></div>
        </div>

        <div class="matchTitle">
          You matched with <span id="matchName">someone</span>
        </div>

        <div class="modalActions">
          <a class="btn" id="messageLink" href="messages.html">Message</a>
          <button class="btn" id="keepSwiping" type="button">Keep swiping</button>
          <button class="btn" id="passMatch" type="button" style="border-color: rgba(255,80,120,35); background: rgba(255,80,120,10);">Pass</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";
    import {
      getFirestore,
      collection,
      doc,
      getDoc,
      getDocs,
      setDoc,
      serverTimestamp,
      query,
      where,
      limit,
      orderBy,
      runTransaction,
      deleteDoc
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyD_k18vbiBsLhQB7PzgEVT9PEI_30Mu0kg",
      authDomain: "uzone-6148d.firebaseapp.com",
      projectId: "uzone-6148d",
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // Elements
    const subline = document.getElementById("subline");
    const msgBox = document.getElementById("msgBox");

    const findFemale = document.getElementById("findFemale");
    const findMale = document.getElementById("findMale");
    const refreshBtn = document.getElementById("refreshBtn");

    const mainImg = document.getElementById("mainImg");
    const prevImg = document.getElementById("prevImg");
    const nextImg = document.getElementById("nextImg");
    const thumbs = document.getElementById("thumbs");

    const candName = document.getElementById("candName");
    const candAge = document.getElementById("candAge");
    const candBio = document.getElementById("candBio");
    const candTags = document.getElementById("candTags");

    const nopeBtn = document.getElementById("nopeBtn");
    const likeBtn = document.getElementById("likeBtn");

    const matchModal = document.getElementById("matchModal");
    const closeMatch = document.getElementById("closeMatch");
    const keepSwiping = document.getElementById("keepSwiping");
    const passMatch = document.getElementById("passMatch");
    const meBubble = document.getElementById("meBubble");
    const themBubble = document.getElementById("themBubble");
    const matchName = document.getElementById("matchName");
    const messageLink = document.getElementById("messageLink");

    const matchesList = document.getElementById("matchesList");
    const matchesEmpty = document.getElementById("matchesEmpty");
    const refreshMatchesBtn = document.getElementById("refreshMatchesBtn");

    const creditsChip = document.getElementById("creditsChip");

    const likedList = document.getElementById("likedList");
    const likedEmpty = document.getElementById("likedEmpty");
    const revealLikeBtn = document.getElementById("revealLikeBtn");
    const superLikeBtn = document.getElementById("superLikeBtn");

    let currentUser = null;

    // State
    let searchGender = "Female"; // "Female" | "Male"
    let candidates = [];         // array of { uid, ...profile }
    let idx = 0;
    let currentPhotos = [];      // array of URLs for current card
    let photoIndex = 0;

    // Cache of swipe decisions: Map<otherUid, { direction: "like"|"dislike", updatedAt }>
    const swipeMap = new Map();

    // Cache of matches: Map<matchId, { otherUid, chatId, name, photoURL }>
    const matchMap = new Map();

    // Liked-you cache: Map<likerUid, { uid, revealed, type, createdAt, name?, photoURL? }>
    const likedMap = new Map();

    let myCredits = 0;

    function setMsg(text, kind="") {
      msgBox.style.display = text ? "block" : "none";
      msgBox.textContent = text || "";
      msgBox.className = "msg" + (kind ? " " + kind : "");
    }

    function placeholderAvatarFromName(name){
      const n = (name || "U").toString().trim() || "U";
      const initials = n.split(/\s+/).slice(0,2).map(x => x[0]?.toUpperCase() || "").join("") || "U";
      const bg = "0b0b10";
      const fg = "ffffff";
      const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'>
        <rect width='100%' height='100%' fill='#${bg}'/>
        <text x='50%' y='56%' text-anchor='middle' font-size='84' fill='#${fg}' font-family='Arial' font-weight='800'>${initials}</text>
      </svg>`;
      return "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(svg);
    }

    function setToggleUI(){
      findFemale.classList.toggle("on", searchGender === "Female");
      findMale.classList.toggle("on", searchGender === "Male");
    }

    function setButtonsEnabled(on){
      nopeBtn.disabled = !on;
      likeBtn.disabled = !on;
      prevImg.disabled = !on || photoIndex === 0;
      nextImg.disabled = !on || photoIndex === currentPhotos.length - 1;
    }

    function currentCandidate(){
      return candidates[idx] || null;
    }

    function displayCandidate(cand){
      if (!cand){
        candName.textContent = "No more profiles";
        candAge.textContent = "";
        candBio.textContent = "Try refresh or switch gender.";
        candTags.innerHTML = "";
        thumbs.innerHTML = "";
        mainImg.src = placeholderAvatarFromName("?");
        currentPhotos = [mainImg.src];
        photoIndex = 0;
        setButtonsEnabled(true);
        prevImg.disabled = true;
        nextImg.disabled = true;
        return;
      }

      candName.textContent = (cand.name || "Student").toString().trim();
      candAge.textContent = cand.age ? `${cand.age}` : "";
      candBio.textContent = (cand.bio || "").toString().trim() || " ";
      candTags.innerHTML = "";

      const tags = Array.isArray(cand.tags) ? cand.tags : [];
      tags.slice(0,8).forEach(t => {
        const span = document.createElement("span");
        span.className = "tag";
        span.textContent = String(t);
        candTags.appendChild(span);
      });

      // Photos
      const photos = Array.isArray(cand.photos) ? cand.photos.filter(Boolean) : [];
      const main = (cand.photoURL || "").toString().trim();

      currentPhotos = [];
      if (photos.length) currentPhotos = photos.slice(0,6);
      else if (main) currentPhotos = [main];
      else currentPhotos = [placeholderAvatarFromName(cand.name || "U")];

      photoIndex = 0;
      mainImg.src = currentPhotos[0];

      thumbs.innerHTML = "";
      currentPhotos.forEach((url, i) => {
        const t = document.createElement("div");
        t.className = "thumb" + (i === 0 ? " active" : "");
        const im = document.createElement("img");
        im.alt = "Photo";
        im.src = url;
        t.appendChild(im);
        t.addEventListener("click", () => {
          photoIndex = i;
          mainImg.src = currentPhotos[photoIndex];
          prevImg.disabled = photoIndex === 0;
          nextImg.disabled = photoIndex === currentPhotos.length - 1;
          [...thumbs.children].forEach((el, j) => el.classList.toggle("active", j === photoIndex));
        });
        thumbs.appendChild(t);
      });

      prevImg.disabled = photoIndex === 0;
      nextImg.disabled = photoIndex === currentPhotos.length - 1;
      setButtonsEnabled(true);
    }

    function nextCandidate(){
      idx += 1;
      displayCandidate(currentCandidate());
    }

    async function refreshCredits(){
      try{
        const meSnap = await getDoc(doc(db, "users", currentUser.uid));
        const me = meSnap.exists() ? (meSnap.data() || {}) : {};
        const c = Number(me.credits ?? 0);
        myCredits = Number.isFinite(c) ? c : 0;
      } catch(_){
        myCredits = myCredits || 0;
      }
      if (creditsChip) creditsChip.textContent = `Credits: ${myCredits}`;
      if (revealLikeBtn) revealLikeBtn.disabled = myCredits <= 0;
      if (superLikeBtn) superLikeBtn.disabled = myCredits <= 0;
    }

    async function spendOneCredit({ reason="spend", targetUid=null } = {}){
      try{
        const meRef = doc(db, "users", currentUser.uid);
        const ok = await runTransaction(db, async (tx) => {
          const snap = await tx.get(meRef);
          const me = snap.exists() ? (snap.data() || {}) : {};
          const c = Number(me.credits ?? 0);
          const credits = Number.isFinite(c) ? c : 0;
          if (credits <= 0) return false;

          tx.set(meRef, { credits: credits - 1, creditsUpdatedAt: serverTimestamp() }, { merge:true });

          const logRef = doc(collection(db, "users", currentUser.uid, "credit_logs"));
          tx.set(logRef, { reason, targetUid: targetUid || null, delta: -1, createdAt: serverTimestamp() }, { merge:true });
          return true;
        });

        if (ok) {
          myCredits = Math.max(0, (myCredits || 0) - 1);
          if (creditsChip) creditsChip.textContent = `Credits: ${myCredits}`;
          if (revealLikeBtn) revealLikeBtn.disabled = myCredits <= 0;
          if (superLikeBtn) superLikeBtn.disabled = myCredits <= 0;
          return true;
        }
        return false;
      } catch(err){
        console.error(err);
        return false;
      }
    }

    async function upsertLikedBy(targetUid, type="like"){
      // Writes into THEIR incoming list: users/{targetUid}/likedBy/{meUid}
      try{
        const meUid = currentUser.uid;
        await setDoc(doc(db, "users", targetUid, "likedBy", meUid), {
          fromUid: meUid,
          type: type || "like", // "like" | "superlike"
          createdAt: serverTimestamp()
        }, { merge:true });
      } catch(err){
        console.warn("likedBy write failed:", err?.message || err);
      }
    }

    async function loadLikedYou(){
      likedMap.clear();
      try{
        const ref = collection(db, "users", currentUser.uid, "likedBy");
        let snaps;
        try{
          const qy = query(ref, orderBy("createdAt", "desc"), limit(60));
          snaps = await getDocs(qy);
        } catch(e){
          snaps = await getDocs(ref);
        }

        const rows = [];
        snaps.forEach(d => {
          const v = d.data() || {};
          rows.push({
            uid: d.id,
            revealed: !!v.revealed,
            type: (v.type || "like"),
            createdAt: v.createdAt || null,
            revealedAt: v.revealedAt || null
          });
        });

        rows.sort((a,b)=>{
          const ta = a.createdAt?.toMillis ? a.createdAt.toMillis() : 0;
          const tb = b.createdAt?.toMillis ? b.createdAt.toMillis() : 0;
          return tb - ta;
        });

        for (const r of rows){
          let name = "";
          let photoURL = "";
          if (r.revealed){
            try{
              const uSnap = await getDoc(doc(db, "users", r.uid));
              if (uSnap.exists()){
                const u = uSnap.data() || {};
                name = (u.name || "Student").toString().trim();
                photoURL = (u.photoURL || "").toString();
              }
            } catch(_) {}
          }
          likedMap.set(r.uid, { ...r, name, photoURL });
        }

        renderLikedYou();
      } catch(err){
        console.error(err);
      }
    }

    function renderLikedYou(){
      if (!likedList) return;
      likedList.innerHTML = "";
      const items = [...likedMap.values()];

      if (!items.length) {
        likedList.appendChild(likedEmpty);
        likedEmpty.style.display = "block";
        return;
      }
      likedEmpty.style.display = "none";

      items.forEach(it => {
        const row = document.createElement("div");
        row.className = "matchRow";
        row.style.cursor = it.revealed ? "pointer" : "default";

        const av = document.createElement("div");
        av.className = "matchAvatar";
        const img = document.createElement("img");
        img.alt = "Like";
        img.src = it.revealed
          ? (it.photoURL || placeholderAvatarFromName(it.name || "U"))
          : placeholderAvatarFromName("?");
        av.appendChild(img);

        const meta = document.createElement("div");
        meta.className = "matchMeta";

        const n = document.createElement("div");
        n.className = "matchName";
        n.textContent = it.revealed ? (it.name || "Student") : "Locked";

        const sub = document.createElement("div");
        sub.className = "matchSub";
        sub.textContent = it.revealed
          ? "View / Pass / Match"
          : ((it.type === "superlike") ? "Someone super liked you" : "Someone liked you");

        meta.appendChild(n);
        meta.appendChild(sub);

        row.appendChild(av);
        row.appendChild(meta);

        if (it.revealed){
          const btns = document.createElement("div");
          btns.className = "rowBtns";

          const viewBtn = document.createElement("button");
          viewBtn.className = "miniBtn";
          viewBtn.type = "button";
          viewBtn.textContent = "View";
          viewBtn.addEventListener("click", (e)=>{
            e.stopPropagation();
            window.location.href = `view_profile.html?uid=${encodeURIComponent(it.uid)}`;
          });

          const passBtn = document.createElement("button");
          passBtn.className = "miniBtn bad";
          passBtn.type = "button";
          passBtn.textContent = "Pass";
          passBtn.addEventListener("click", async (e)=>{
            e.stopPropagation();
            await decideOnRevealedLike(it.uid, "dislike");
          });

          const matchBtn = document.createElement("button");
          matchBtn.className = "miniBtn good";
          matchBtn.type = "button";
          matchBtn.textContent = "Match";
          matchBtn.addEventListener("click", async (e)=>{
            e.stopPropagation();
            await decideOnRevealedLike(it.uid, "like");
          });

          btns.appendChild(viewBtn);
          btns.appendChild(passBtn);
          btns.appendChild(matchBtn);

          row.addEventListener("click", ()=> {
            window.location.href = `view_profile.html?uid=${encodeURIComponent(it.uid)}`;
          });

          row.appendChild(btns);
        }

        likedList.appendChild(row);
      });
    }

    async function revealNextLike(){
      const locked = [...likedMap.values()].filter(x => !x.revealed);
      if (!locked.length){
        setMsg("No locked likes to reveal.", "ok");
        return;
      }

      const ok = await spendOneCredit({ reason:"reveal_like", targetUid: locked[0].uid });
      if (!ok){
        setMsg("You need a credit to reveal who liked you.", "error");
        await refreshCredits();
        return;
      }

      try{
        await setDoc(doc(db, "users", currentUser.uid, "likedBy", locked[0].uid), {
          revealed: true,
          revealedAt: serverTimestamp()
        }, { merge:true });

        await loadLikedYou();
        setMsg("Revealed 1 like.", "ok");
      } catch(err){
        console.error(err);
        setMsg("Couldn’t reveal right now.", "error");
      }
    }

    async function decideOnRevealedLike(otherUid, direction){
      // direction: "like" | "dislike"
      try{
        await setDoc(doc(db, "users", currentUser.uid, "swipes", otherUid), {
          direction,
          updatedAt: serverTimestamp()
        }, { merge:true });

        swipeMap.set(otherUid, { direction });

        if (direction === "like"){
          const theirSwipeRef = doc(db, "users", otherUid, "swipes", currentUser.uid);
          const theirSnap = await getDoc(theirSwipeRef);
          const theirDir = theirSnap.exists() ? (theirSnap.data()?.direction || "") : "";

          if (theirDir === "like"){
            const meSnap = await getDoc(doc(db, "users", currentUser.uid));
            const me = meSnap.exists() ? (meSnap.data() || {}) : {};
            const themSnap = await getDoc(doc(db, "users", otherUid));
            const them = themSnap.exists() ? (themSnap.data() || {}) : {};

            const mePhoto = (me?.photoURL || "") || placeholderAvatarFromName(me?.name || "U");
            const themPhoto = (them?.photoURL || "") || placeholderAvatarFromName(them?.name || "U");

            const chatId = await ensureChat(currentUser.uid, otherUid);
            await ensureMatch(currentUser.uid, otherUid);

            meBubble.src = mePhoto;
            themBubble.src = themPhoto;
            matchName.textContent = (them?.name || "Student").toString().trim();
            messageLink.href = `messages.html?chat=${encodeURIComponent(chatId)}&with=${encodeURIComponent(otherUid)}`;

            matchModal.style.display = "flex";
            await loadMatches();
          }
        }

        await setDoc(doc(db, "users", currentUser.uid, "likedBy", otherUid), {
          handled: true,
          handledAt: serverTimestamp(),
          handledDirection: direction
        }, { merge:true });

        await loadLikedYou();
      } catch(err){
        console.error(err);
        setMsg(err?.message || "Couldn’t apply decision.", "error");
      }
    }

    function chatIdFor(u1, u2){
      return [u1, u2].sort().join("_");
    }

    async function ensureChat(u1, u2){
      const chatId = chatIdFor(u1, u2);
      const chatRef = doc(db, "chats", chatId);
      const snap = await getDoc(chatRef);
      if (!snap.exists()) {
        await setDoc(chatRef, {
          members: [u1, u2].sort(),
          createdAt: serverTimestamp(),
          lastMessageAt: serverTimestamp()
        }, { merge: true });
      }
      return chatId;
    }

    async function ensureMatch(u1, u2){
      const matchId = chatIdFor(u1, u2);
      const matchRef = doc(db, "matches", matchId);
      const snap = await getDoc(matchRef);
      if (!snap.exists()) {
        await setDoc(matchRef, {
          members: [u1, u2].sort(),
          createdAt: serverTimestamp()
        }, { merge: true });
      }
      return matchId;
    }

    function openChatWith(otherUid){
      const chatId = chatIdFor(currentUser.uid, otherUid);
      window.location.href = `messages.html?chat=${encodeURIComponent(chatId)}&with=${encodeURIComponent(otherUid)}`;
    }

    function renderMatches(){
      matchesList.innerHTML = "";
      const items = [...matchMap.values()];

      if (!items.length) {
        matchesList.appendChild(matchesEmpty);
        matchesEmpty.style.display = "block";
        return;
      }

      matchesEmpty.style.display = "none";

      items.forEach(m => {
        const row = document.createElement("div");
        row.className = "matchRow";

        const av = document.createElement("div");
        av.className = "matchAvatar";
        const img = document.createElement("img");
        img.alt = "Match";
        img.src = m.photoURL || placeholderAvatarFromName(m.name || "U");
        av.appendChild(img);

        const meta = document.createElement("div");
        meta.className = "matchMeta";

        const n = document.createElement("div");
        n.className = "matchName";
        n.textContent = m.name || "Student";

        const sub = document.createElement("div");
        sub.className = "matchSub";
        sub.textContent = " ";

        meta.appendChild(n);
        meta.appendChild(sub);

        const btns = document.createElement("div");
        btns.className = "rowBtns";

        const viewBtn = document.createElement("button");
        viewBtn.className = "miniBtn";
        viewBtn.type = "button";
        viewBtn.textContent = "View";
        viewBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          window.location.href = `view_profile.html?uid=${encodeURIComponent(m.otherUid)}`;
        });

        const msgBtn = document.createElement("button");
        msgBtn.className = "miniBtn";
        msgBtn.type = "button";
        msgBtn.textContent = "Message";
        msgBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          openChatWith(m.otherUid);
        });

        btns.appendChild(viewBtn);
        btns.appendChild(msgBtn);

        const passBtn = document.createElement("button");
        passBtn.className = "miniBtn bad";
        passBtn.type = "button";
        passBtn.textContent = "Pass";
        passBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          await removeMatch(m.matchId, m.otherUid);
        });

        btns.appendChild(passBtn);

        row.addEventListener("click", () => openChatWith(m.otherUid));

        row.appendChild(av);
        row.appendChild(meta);
        row.appendChild(btns);

        matchesList.appendChild(row);
      });
    }

    async function loadMatches(){
      matchMap.clear();

      try{
        const matchesRef = collection(db, "matches");
        const q = query(matchesRef, where("members", "array-contains", currentUser.uid), limit(50));
        const snaps = await getDocs(q);

        for (const d of snaps.docs){
          const data = d.data() || {};
          const members = Array.isArray(data.members) ? data.members : [];
          const otherUid = members.find(x => x !== currentUser.uid);
          if (!otherUid) continue;

          let name = "";
          let photoURL = "";
          try{
            const uSnap = await getDoc(doc(db, "users", otherUid));
            if (uSnap.exists()){
              const u = uSnap.data() || {};
              name = (u.name || "Student").toString().trim();
              photoURL = (u.photoURL || "").toString().trim();
            }
          } catch(_){}

          matchMap.set(d.id, {
            matchId: d.id,
            otherUid,
            chatId: chatIdFor(currentUser.uid, otherUid),
            name,
            photoURL
          });
        }

        renderMatches();
      } catch(err){
        console.error(err);
      }
    }

    async function removeMatch(matchId, otherUid){
      if (!currentUser || !matchId || !otherUid) return;
      try{
        // Delete match doc
        await deleteDoc(doc(db, "matches", matchId));

        // Mark as dislike so you don't instantly rematch
        await setDoc(
          doc(db, "users", currentUser.uid, "swipes", otherUid),
          { direction: "dislike", updatedAt: serverTimestamp() },
          { merge: true }
        );
        swipeMap.set(otherUid, { direction: "dislike" });

        await loadMatches();
      } catch(err){
        console.error(err);
      }
    }

    // Controls
    prevImg.addEventListener("click", () => {
      if (photoIndex > 0) photoIndex -= 1;
      mainImg.src = currentPhotos[photoIndex];
      prevImg.disabled = photoIndex === 0;
      nextImg.disabled = photoIndex === currentPhotos.length - 1;
      [...thumbs.children].forEach((el, i) => el.classList.toggle("active", i === photoIndex));
    });
    nextImg.addEventListener("click", () => {
      if (photoIndex < currentPhotos.length - 1) photoIndex += 1;
      mainImg.src = currentPhotos[photoIndex];
      prevImg.disabled = photoIndex === 0;
      nextImg.disabled = photoIndex === currentPhotos.length - 1;
      [...thumbs.children].forEach((el, i) => el.classList.toggle("active", i === photoIndex));
    });

    findFemale.addEventListener("click", async () => {
      searchGender = "Female";
      setToggleUI();
      await loadCandidates();
    });
    findMale.addEventListener("click", async () => {
      searchGender = "Male";
      setToggleUI();
      await loadCandidates();
    });

    refreshBtn.addEventListener("click", async () => {
      await loadCandidates();
    });

    nopeBtn.addEventListener("click", () => swipe("dislike"));
    likeBtn.addEventListener("click", () => swipe("like"));

    // Credit-gated: reveal who liked you
    revealLikeBtn.addEventListener("click", revealNextLike);

    // Credit-gated: Super Like (spends 1 credit, counts as a Like, and flags as superlike on their Liked You list)
    superLikeBtn.addEventListener("click", async () => {
      const cand = currentCandidate();
      if (!cand) return;

      setButtonsEnabled(false);
      setMsg("");

      const otherUid = cand.uid;

      const ok = await spendOneCredit({ reason:"super_like", targetUid: otherUid });
      if (!ok){
        setMsg("You need a credit to Super Like.", "error");
        setButtonsEnabled(true);
        await refreshCredits();
        return;
      }

      try{
        await setDoc(doc(db, "users", currentUser.uid, "swipes", otherUid), {
          direction: "like",
          updatedAt: serverTimestamp(),
          superlike: true
        }, { merge:true });

        swipeMap.set(otherUid, { direction: "like" });

        await upsertLikedBy(otherUid, "superlike");

        const theirSnap = await getDoc(doc(db, "users", otherUid, "swipes", currentUser.uid));
        const theirDir = theirSnap.exists() ? (theirSnap.data()?.direction || "") : "";

        if (theirDir === "like") {
          const meSnap = await getDoc(doc(db, "users", currentUser.uid));
          const meProfile = meSnap.exists() ? meSnap.data() : {};
          const mePhoto = (meProfile?.photoURL || "") || placeholderAvatarFromName(meProfile?.name || "U");
          const themPhoto = (cand.photoURL || "") || placeholderAvatarFromName(cand.name || "U");

          const chatId = await ensureChat(currentUser.uid, otherUid);
          await ensureMatch(currentUser.uid, otherUid);

          meBubble.src = mePhoto;
          themBubble.src = themPhoto;
          matchName.textContent = (cand.name || "Student").toString().trim();
          messageLink.href = `messages.html?chat=${encodeURIComponent(chatId)}&with=${encodeURIComponent(otherUid)}`;

          matchModal.style.display = "flex";
          await loadMatches();
        }
      } catch(err){
        console.error(err);
        setMsg(err?.message || "Super Like failed.", "error");
      } finally{
        setButtonsEnabled(true);
        nextCandidate();
      }
    });

    refreshMatchesBtn.addEventListener("click", loadMatches);

    closeMatch.addEventListener("click", () => { matchModal.style.display = "none"; });
    keepSwiping.addEventListener("click", () => { matchModal.style.display = "none"; });

    passMatch.addEventListener("click", async () => {
      // If you pass from the modal, we also mark current candidate as dislike and close
      matchModal.style.display = "none";
      const cand = currentCandidate();
      if (cand?.uid){
        try{
          await setDoc(doc(db, "users", currentUser.uid, "swipes", cand.uid), {
            direction: "dislike",
            updatedAt: serverTimestamp()
          }, { merge:true });
          swipeMap.set(cand.uid, { direction:"dislike" });
        } catch(_){}
      }
    });

    async function loadCandidates(){
      setMsg("");
      subline.textContent = "Loading profiles…";
      candidates = [];
      idx = 0;

      try{
        // Load my swipes
        swipeMap.clear();
        try{
          const swSnap = await getDocs(collection(db, "users", currentUser.uid, "swipes"));
          swSnap.forEach(d => {
            const v = d.data() || {};
            if (v?.direction) swipeMap.set(d.id, { direction: v.direction });
          });
        } catch(_){}

        // Get users of target gender
        const usersRef = collection(db, "users");
        const qy = query(usersRef, where("gender", "==", searchGender), limit(80));
        const snaps = await getDocs(qy);

        const list = [];
        snaps.forEach(d => {
          if (d.id === currentUser.uid) return;
          const u = d.data() || {};
          // Skip unverified if you ever need:
          // if (!u.verified) return;
          if (swipeMap.has(d.id)) return; // already decided
          list.push({ uid: d.id, ...u });
        });

        // Shuffle
        for (let i = list.length - 1; i > 0; i--){
          const j = Math.floor(Math.random() * (i + 1));
          [list[i], list[j]] = [list[j], list[i]];
        }

        candidates = list;

        if (!candidates.length){
          subline.textContent = "No profiles found";
        } else {
          subline.textContent = `Showing ${searchGender.toLowerCase()} profiles`;
        }

        displayCandidate(currentCandidate());
      } catch(err){
        console.error(err);
        subline.textContent = "Couldn’t load profiles";
        setMsg(err?.message || "Couldn’t load profiles.", "error");
        displayCandidate(null);
      }
    }

    async function swipe(direction){
      const cand = currentCandidate();
      if (!cand) return;

      setButtonsEnabled(false);
      setMsg("");

      const otherUid = cand.uid;
      const myUid = currentUser.uid;

      try{
        await setDoc(doc(db, "users", myUid, "swipes", otherUid), {
          direction, // "like" | "dislike"
          updatedAt: serverTimestamp()
        }, { merge: true });

        swipeMap.set(otherUid, { direction });

        if (direction === "like") {
          // Add me to their "Liked you" list (locked on their side until they spend credits)
          await upsertLikedBy(otherUid, "like");

          const theirSwipeRef = doc(db, "users", otherUid, "swipes", myUid);
          const theirSnap = await getDoc(theirSwipeRef);
          const theirDir = theirSnap.exists() ? (theirSnap.data()?.direction || "") : "";

          if (theirDir === "like") {
            const meSnap = await getDoc(doc(db, "users", myUid));
            const meProfile = meSnap.exists() ? meSnap.data() : {};
            const mePhoto = (meProfile?.photoURL || "") || placeholderAvatarFromName(meProfile?.name || "U");
            const themPhoto = (cand.photoURL || "") || placeholderAvatarFromName(cand.name || "U");

            const chatId = await ensureChat(myUid, otherUid);
            await ensureMatch(myUid, otherUid);

            meBubble.src = mePhoto;
            themBubble.src = themPhoto;
            matchName.textContent = (cand.name || "Student").toString().trim();

            messageLink.href = `messages.html?chat=${encodeURIComponent(chatId)}&with=${encodeURIComponent(otherUid)}`;

            matchModal.style.display = "flex";
            await loadMatches();
          }
        }
      } catch(err){
        setMsg(err?.message || "Swipe failed.", "error");
      } finally{
        setButtonsEnabled(true);
        nextCandidate();
      }
    }

    onAuthStateChanged(auth, async (user) => {
      if (!user) { window.location.href = "index.html"; return; }
      currentUser = user;
      subline.textContent = "Loading…";
      setToggleUI();

      await refreshCredits();
      await loadCandidates();
      await loadMatches();
      await loadLikedYou();
    });
  </script>
</body>
</html>
